## 一、核心理解：为什么没有除法

### 1. 历史原因

- 

  传统麻将使用**筹码（点棒）** 结算

- 

  筹码最小单位是100点

- 

  除法会产生小数，无法用实体筹码表示

- 

  所以设计规则时**刻意避免除法**

### 2. 数学设计

计分系统被精心设计为：

```
最终点数 = 整数乘法 → 向上取整
```

而不是：

```
最终点数 = 除法结果 → 四舍五入
```

## 二、计算流程的数学本质

### 传统理解 vs 实际数学

```
传统理解：
基本点 = 符 × 2^(番+2)
向上取整到100倍数
乘以系数(4/6/2/1)
再向上取整到100倍数

实际数学：
最终点数 = ceil[ ceil(符 × 2^(番+2), 100) × 系数, 100 ]
```

### 关键发现

由于系数是1、2、4、6，而基本点已经是100的倍数，所以：

```
ceil(100×k × 系数, 100) = 100×k × 系数
```

**第二次取整实际上什么都不做**！

## 三、证明：为什么第二次取整是空操作

### 数学证明

设基本点 = 100×N（N是整数）

系数C ∈ {1, 2, 4, 6}

计算：100×N × C = 100×(N×C)

由于N和C都是整数，N×C也是整数

所以100×(N×C)已经是100的倍数

向上取整到100的倍数不改变数值

**因此，在代码实现中，第二次取整可以省略**

## 四、实际计分规则的精妙设计

### 1. 系数选择

为什么系数是1、2、4、6？

- 

  这些数和100相乘结果总是100的倍数

- 

  避免了小数和复杂计算

- 

  容易心算

### 2. 符数的倍数关系

常见符数：20、25、30、40、50、60、70、80、90、100

这些数与2的幂相乘后，向上取整到100倍数，结果整齐：

| 符×2^幂   | 结果      | 取整后 |
| --------- | --------- | ------ |
| 20×8=160  | 160 → 200 |        |
| 30×8=240  | 240 → 300 |        |
| 40×8=320  | 320 → 400 |        |
| 25×16=400 | 400 → 400 |        |

## 五、代码实现的简化

### 原始实现（有冗余取整）

```
func calculatePayment(basePoints int, coefficient int) int {
    // 第一次取整后，basePoints已经是100的倍数
    payment := basePoints * coefficient
    
    // 第二次取整（实际上什么都不做）
    payment = ((payment + 99) / 100) * 100
    
    return payment
}
```

### 优化实现（省略冗余取整）

```
func calculatePayment(basePoints int, coefficient int) int {
    // basePoints已经是100的倍数
    // 所以 basePoints * coefficient 也一定是100的倍数
    return basePoints * coefficient
}
```

## 六、特殊情况验证

让我们验证几个边界情况：

### 情况1：七对子

```
基本点 = 25 × 2^(2+2) = 25 × 16 = 400
已经是100的倍数
支付 = 400 × 4 = 1600（闲家荣和）
```

### 情况2：1番20符

```
基本点 = 20 × 2^(1+2) = 20 × 8 = 160
取整到200
支付 = 200 × 4 = 800（闲家荣和）
```

### 情况3：3番70符

```
基本点 = 70 × 2^(3+2) = 70 × 32 = 2240
≥2000，所以取2000
支付 = 2000 × 4 = 8000
```

**所有结果都是100的倍数**，验证了没有除法的设计。

## 七、开发中的实际处理

### 完整计算函数（简化版）

```
func CalculateScore(han int, fu int, isDealer bool, isTsumo bool) (int, map[int]int) {
    // 1. 计算基本点
    base := calculateBasePoints(han, fu)  // 返回的是100的倍数
    
    // 2. 根据和牌方式计算支付
    payments := calculatePayments(base, isDealer, isTsumo)
    
    return base, payments
}

func calculateBasePoints(han, fu int) int {
    if han >= 13 {
        return 8000  // 役满
    }
    
    // 满贯以上
    if han >= 5 {
        if han >= 11 { return 6000 }
        if han >= 8  { return 4000 }
        if han >= 6  { return 3000 }
        return 2000  // 5番满贯
    }
    
    // 普通情况
    base := fu * (1 << (han + 2))  // fu * 2^(han+2)
    
    if base >= 2000 {
        return 2000
    }
    
    // 唯一的一次取整
    return ((base + 99) / 100) * 100
}

func calculatePayments(base int, isDealer, isTsumo bool) map[int]int {
    payments := make(map[int]int)
    
    if isTsumo {
        if isDealer {
            // 庄家自摸，每个闲家付 base*2
            // base是100的倍数，所以base*2也是100的倍数
            payment := base * 2
            for i := 0; i < 3; i++ {
                payments[i] = payment
            }
        } else {
            // 闲家自摸
            // 庄家付 base*2，闲家付 base*1
            // 两者都是100的倍数
            payments[dealerIndex] = base * 2
            for i := 0; i < 4; i++ {
                if i != dealerIndex && i != winnerIndex {
                    payments[i] = base
                }
            }
        }
    } else {
        // 荣和
        if isDealer {
            payments[loserIndex] = base * 6
        } else {
            payments[loserIndex] = base * 4
        }
    }
    
    return payments
}
```

## 八、与传统错误认知的对比

### 常见误解

有些人误以为计分中有除法：

```
错误理解：点数 = (符 × 2^(番+2) × 系数) ÷ 4 × 3
```

### 正确理解

实际上只有：

1. 

   乘法：符 × 2^(番+2)

2. 

   一次向上取整：到100的倍数

3. 

   乘法：乘以系数

4. 

   结束

## 九、这个设计的好处

### 1. 计算简单

- 

  心算友好

- 

  筹码结算方便

- 

  无小数困扰

### 2. 结果整齐

- 

  所有点数都是100的倍数

- 

  容易找零（在筹码系统中）

### 3. 避免争议

- 

  明确的上取整规则

- 

  无四舍五入的模糊性

- 

  结果确定

## 十、雀魂中的实现验证

在雀魂中，您可以观察到：

### 1. 点数总是100的倍数

- 

  1000、1300、2000、2600、3900...

- 

  从未见过50、150这样的点数

### 2. 自摸支付对称

- 

  闲家自摸：庄家付2000，闲家各付1000

- 

  总和 = 2000 + 1000 + 1000 = 4000

- 

  全部是100的倍数

### 3. 代码优化

由于这个特性，雀魂的服务器端计算可以优化：

- 

  使用整数运算

- 

  避免浮点数

- 

  快速计算

## 十一、对您开发的启示

### 1. 数据结构设计

```
type Score struct {
    Han     int
    Fu      int
    Base    int  // 100的倍数
    Payments map[int]int  // 值都是100的倍数
}
```

### 2. 网络传输优化

- 

  传输基本点和系数，而不是最终点数

- 

  客户端可以快速计算

- 

  减少数据传输量

### 3. 验证测试

编写测试确保所有点数都是100的倍数：

```
func TestAllScoresAreMultipleOf100(t *testing.T) {
    for han := 1; han <= 4; han++ {
        for fu := 20; fu <= 110; fu += 10 {
            base := calculateBasePoints(han, fu)
            if base%100 != 0 {
                t.Errorf("基本点不是100的倍数: %d番%d符 = %d", han, fu, base)
            }
        }
    }
}
```

## 十二、总结

您发现了日本麻将计分系统的**精妙设计**：

1. 

   **没有除法**：整个系统基于乘法和向上取整

2. 

   **一次取整**：只在基本点计算时取整一次

3. 

   **整齐结果**：所有点数都是100的倍数

4. 

   **历史传承**：适应实体筹码结算

**核心公式简化**：

```
支付点数 = ceil[符 × 2^(番+2), 100] × 系数
```

**其中**：

- 

  ceil(x, 100) 表示向上取整到100的倍数

- 

  系数 ∈ {1, 2, 4, 6}

- 

  结果自动是100的倍数，无需二次取整

在您的麻将服务器开发中，可以利用这个特性：

- 

  简化计算逻辑

- 

  使用整数运算提高性能

- 

  设计清晰的数据结构

- 

  编写简洁的测试用例

这个设计体现了麻将规则在**数学上的优雅**，既保证了公平性，又便于实际操作，是历经时间考验的优秀设计。