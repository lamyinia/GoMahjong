# 从番符到实际得分的完整计算流程

## 一、完整计算流程总览

```
手牌 → 番数+符数 → 基本点 → 实际点数 → 支付分数
      （计算役）  （公式）  （取整）   （倍数+取整）
```

## 二、核心计算步骤详解

### 步骤1：计算基本点（最重要的一步）

**基本点公式**：`基本点 = 符 × 2^(番+2)`

**但！这里有三个关键规则**：

#### 规则1：基本点的上限

```
如果基本点 ≥ 2000 → 固定为2000
这意味着：4番40符及以上就直接按满贯处理
```

#### 规则2：基本点的下限

```
最小基本点 = 20符 × 2^(1+2) = 160
但由于有取整规则，实际会变成200
```

#### 规则3：特殊牌型

- 七对子：固定25符，基本点固定为400

- 国士无双：不计符，直接役满

**计算示例**：

```
2番30符：30 × 2^(2+2) = 30 × 16 = 480
3番40符：40 × 2^(3+2) = 40 × 32 = 1280
4番30符：30 × 2^(4+2) = 30 × 64 = 1920
4番40符：40 × 64 = 2560（≥2000，所以按2000算）
```

### 步骤2：基本点取整（第一次取整）

**规则**：将基本点向上取整到**100的倍数**

**为什么要取整**：麻将点数必须是100的倍数，方便计算

**示例**：

```
240 → 300  （向上取到下一个100的倍数）
480 → 500
1280 → 1300
1920 → 2000（注意：1920向上取整是2000，这很重要！）
```

**关键点**：

- 4番30符基本点1920 → 取整2000 → 刚好是满贯的阈值

- 这就是为什么4番30符是7700点，4番40符是8000点（满贯）的原因

### 步骤3：应用倍数系数

根据和牌方式不同，乘以不同系数：

| 和牌方式 | 支付者   | 系数 | 公式     |
| -------- | -------- | ---- | -------- |
| 闲家荣和 | 放铳者   | ×4   | 基本点×4 |
| 庄家荣和 | 放铳者   | ×6   | 基本点×6 |
| 闲家自摸 | 庄家     | ×2   | 基本点×2 |
| 闲家自摸 | 其他闲家 | ×1   | 基本点×1 |
| 庄家自摸 | 所有闲家 | ×2   | 基本点×2 |

**计算示例**：

```
1. 闲家荣和，基本点300：
   300 × 4 = 1200

2. 庄家荣和，基本点500：
   500 × 6 = 3000

3. 闲家自摸，基本点300：
   庄家付：300×2 = 600
   其他闲家各付：300×1 = 300
   和牌者得：600 + 300 + 300 = 1200
```

### 步骤4：支付分数取整（第二次取整）

**规则**：每个支付者的支付额向上取整到**100的倍数**

**注意**：自摸时每个支付者分别计算取整

**为什么需要第二次取整**：

理论上基本点取整后已经是100的倍数，乘以整数系数后应该还是100的倍数，但：

1. 庄家自摸时，基本点×2，如果基本点不是50的倍数，可能导致结果不是100的倍数

2. 但实际由于基本点已经是100的倍数，所以这一步通常不改变数值

**示例**：

```
庄家自摸，基本点300：
每个闲家付：300×2 = 600（已是100的倍数，不变）

闲家自摸，基本点200：
庄家付：200×2 = 400（不变）
闲家付：200×1 = 200（不变）
```

## 三、满贯以上的特殊处理

### 满贯以上跳过基本点计算

| 条件    | 名称   | 基本点 | 荣和点数 |
| ------- | ------ | ------ | -------- |
| 5番     | 满贯   | 2000   | 8000     |
| 6-7番   | 跳满   | 3000   | 12000    |
| 8-10番  | 倍满   | 4000   | 16000    |
| 11-12番 | 三倍满 | 6000   | 24000    |
| 13番+   | 役满   | 8000   | 32000    |

**重要**：满贯以上时：

1. 不计算基本点

2. 直接使用上表的固定基本点

3. 乘以系数后**不需要再次取整**（因为已经是100的倍数）

## 四、实战计算示例（跟着算一遍）

### 示例1：最常见的3番30符

```
步骤1：基本点 = 30 × 2^(3+2) = 30 × 32 = 960
步骤2：取整到100的倍数 → 1000
步骤3：应用系数
  荣和时：
    闲家：1000×4 = 4000
    庄家：1000×6 = 6000
  自摸时：
    闲家自摸：庄家付1000×2=2000，闲家各付1000×1=1000
    庄家自摸：每个闲家付1000×2=2000
```

### 示例2：边缘情况4番30符

```
步骤1：基本点 = 30 × 2^(4+2) = 30 × 64 = 1920
步骤2：向上取整 → 2000
步骤3：应用系数
  荣和时：
    闲家：2000×4 = 8000（刚好满贯！）
    庄家：2000×6 = 12000（跳满！）

关键理解：1920取整到2000，导致4番30符=满贯点数
这就是为什么4番30符是"伪满贯"
```

### 示例3：4番40符

```
步骤1：基本点 = 40 × 2^(4+2) = 40 × 64 = 2560
步骤2：2560 ≥ 2000，所以基本点 = 2000
步骤3：直接满贯8000点
```

## 五、特殊牌型计算

### 七对子

```
固定25符，2番
基本点 = 25 × 2^(2+2) = 25 × 16 = 400
取整：400（已整）
闲家荣和：400×4 = 1600
庄家荣和：400×6 = 2400
```

### 平和

```
固定符数：
  自摸：20符
  荣和：30符
基本点计算正常
```

## 六、点数速查表（重要！）

### 闲家荣和点数表

| 番\符 | 20符 | 25符 | 30符 | 40符 | 50符 | 60符 | 70符 | 80符 | 90符 | 100符 |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
| 1番   | 700  | -    | 1000 | 1300 | 1600 | 2000 | 2300 | 2600 | 2900 | 3200  |
| 2番   | 1300 | 1600 | 2000 | 2600 | 3200 | 3900 | 4500 | 5200 | 5800 | 6400  |
| 3番   | 2600 | 3200 | 3900 | 5200 | 6400 | 7700 | 8000 | 8000 | 8000 | 8000  |
| 4番   | 5200 | 6400 | 7700 | 8000 | 8000 | 8000 | 8000 | 8000 | 8000 | 8000  |
| 5番   | 8000 | 8000 | 8000 | 8000 | 8000 | 8000 | 8000 | 8000 | 8000 | 8000  |

**记忆要点**：

- 3番30符 = 3900

- 4番30符 = 7700

- 4番40符 = 8000（满贯）

- 3番60符 = 7700

- 3番70符 = 8000（满贯）

## 七、开发实现逻辑

### 伪代码实现

```
// 计算基本点
func CalculateBasePoints(han int, fu int) int {
    // 役满处理
    if han >= 13 {
        return 8000  // 役满基本点
    }
    
    // 满贯以上处理
    if han >= 5 {
        if han >= 11 {
            return 6000  // 三倍满
        } else if han >= 8 {
            return 4000  // 倍满
        } else if han >= 6 {
            return 3000  // 跳满
        } else {
            return 2000  // 满贯
        }
    }
    
    // 普通情况计算基本点
    base := fu * (1 << (han + 2))  // fu * 2^(han+2)
    
    // 检查是否达到满贯
    if base >= 2000 {
        return 2000
    }
    
    // 向上取整到100的倍数
    return ((base + 99) / 100) * 100
}

// 计算最终支付点数
func CalculatePayments(basePoints int, isDealer bool, isTsumo bool) map[int]int {
    payments := make(map[int]int)
    
    if isTsumo {
        if isDealer {
            // 庄家自摸，每个闲家付 basePoints * 2
            payment := basePoints * 2
            // 确保是100的倍数（通常已经是）
            payment = ((payment + 99) / 100) * 100
            for i := 1; i <= 3; i++ {
                payments[i] = payment
            }
        } else {
            // 闲家自摸
            // 庄家付 basePoints * 2
            dealerPayment := basePoints * 2
            dealerPayment = ((dealerPayment + 99) / 100) * 100
            payments[0] = dealerPayment  // 假设0是庄家
            
            // 其他闲家各付 basePoints
            otherPayment := basePoints
            otherPayment = ((otherPayment + 99) / 100) * 100
            for i := 1; i <= 3; i++ {
                if i != winningPlayer {  // 跳过和牌者
                    payments[i] = otherPayment
                }
            }
        }
    } else {
        // 荣和
        if isDealer {
            payment := basePoints * 6
        } else {
            payment := basePoints * 4
        }
        payment = ((payment + 99) / 100) * 100
        payments[loserIndex] = payment
    }
    
    return payments
}
```

### 简化计算逻辑

实际上，由于基本点取整后是100的倍数，可以简化：

```
// 快速计算函数
func QuickCalculate(han, fu int, isDealer, isTsumo bool) (int, map[int]int) {
    // 1. 计算基本点
    base := calculateBase(han, fu)
    
    // 2. 如果是满贯以上，使用固定表
    if base >= 2000 {
        return calculateMangan(han, base, isDealer, isTsumo)
    }
    
    // 3. 普通情况
    return calculateNormal(base, isDealer, isTsumo)
}
```

## 八、雀魂中的实际表现

在雀魂中，您不需要手动计算，但了解原理有助于：

### 1. 和牌时显示的信息

```
和了！
役：立直、一发、门前清自摸
番数：3番
符数：30符
点数：3900/2000
```

- 3900是荣和点数

- 2000是自摸时每家支付的基本点

### 2. 点数预测功能

- 听牌时会显示可能的和牌点数范围

- 基于当前番符估算

- 考虑了取整规则

### 3. 学习模式

- 详细显示计算过程

- 展示每一步取整

- 帮助玩家理解计分

## 九、常见误解澄清

### 误解1：番和符是相加的

❌ 错误：点数 = 番 + 符

✅ 正确：基本点 = 符 × 2^(番+2)

### 误解2：取整只做一次

实际是**两次取整**：

1. 基本点向上取整到100的倍数

2. 每个支付额向上取整到100的倍数

### 误解3：满贯是8000点

不完全对：

- 满贯的**基本点**是2000

- 闲家荣和满贯是2000×4=8000

- 庄家荣和满贯是2000×6=12000

- 自摸满贯是每家支付2000

## 十、实用速算技巧

### 快速估算点数

```
1. 先记关键点：
   - 3番30符 = 3900
   - 4番30符 = 7700
   - 满贯 = 8000

2. 每增加1番，点数约翻倍
   - 1番 → 2番：1000→2000
   - 2番 → 3番：2000→3900
   - 3番 → 4番：3900→7700

3. 符数影响：
   - 低番时（1-2番）：符数影响大
   - 高番时（3+番）：主要看番数
```

### 开发时的验证测试

```
// 测试用例
testCases := []struct{
    han, fu int
    expectedPoints int
}{
    {1, 30, 1000},  // 闲家荣和
    {2, 30, 2000},
    {3, 30, 3900},
    {4, 30, 7700},
    {4, 40, 8000},  // 满贯
    {5, 30, 8000},  // 满贯
    {6, 30, 12000}, // 跳满
}
```

## 总结

**从番符到实际得分的完整链条**：

```
1. 计算役 → 得到番数
2. 分析手牌构造 → 得到符数
3. 基本点 = 符 × 2^(番+2)
4. 如果基本点≥2000 → 固定为2000（满贯阈值）
5. 否则向上取整到100的倍数
6. 乘以系数（×4、×6、×2、×1）
7. 每个支付额向上取整到100的倍数
8. 加上本场费(300×本场数)和立直棒(1000×本)
```

**关键记忆点**：

- **两次取整**：基本点一次，支付额一次

- **满贯阈值**：基本点2000对应荣和8000点

- **伪满贯**：4番30符=7700，非常接近满贯

- **实际游玩**：记住3番30符=3900，4番30符=7700，5番=满贯8000

在雀魂中，这个计算是自动完成的，但了解原理可以帮助您：

1. 判断一手牌的价值

2. 决定是否要追求更高番数

3. 理解为什么某些牌型点数特别高

4. 制定更有效的做牌策略