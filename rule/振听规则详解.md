# 振听（フリテン）规则详解

振听是立直麻将中重要的限制规则，直接影响和牌方式。

## 一、振听的基本概念

### 1.1 定义

振听是指**不能荣和**的状态，但可以自摸和牌。

### 1.2 核心规则

- **不能荣和**：处于振听状态时，不能荣和其他玩家打出的牌
- **可以自摸**：振听不影响自摸和牌
- **必须解除**：只有改变听牌或自摸和牌才能解除振听

## 二、振听的类型

### 2.1 舍牌振听（すてふり）

#### 定义

听牌中包含**自己打过的牌**。

#### 示例

```
手牌：1万 2万 3万 4万 5万
听牌：1万、4万

如果之前打过1万或4万
→ 处于舍牌振听
→ 不能荣和1万或4万
→ 但可以自摸1万或4万
```

#### 判断方法

1. **检查听牌**：确定当前听牌
2. **检查舍牌**：查看牌河中自己打过的牌
3. **对比**：如果听牌中包含舍牌，则振听

#### 解除方法

- **改变听牌**：打出听牌中的牌，改变听牌
- **自摸和牌**：自摸和牌后自然解除

### 2.2 同巡振听（どうじゅんふり）

#### 定义

**本巡内**可以荣和但选择不荣和。

#### 示例

```
玩家A打出：3万
玩家B可以荣和3万，但选择不荣和
→ 玩家B进入同巡振听
→ 本巡内不能再荣和任何牌
→ 但可以自摸和牌
```

#### 判断方法

1. **检查可荣和牌**：本巡内是否有可以荣和的牌
2. **检查是否荣和**：如果选择不荣和，进入振听
3. **持续到下一巡**：下一巡自动解除

#### 解除方法

- **下一巡**：自动解除
- **自摸和牌**：自摸和牌后自然解除

### 2.3 立直后振听（リーチごふり）

#### 定义

**立直后**可以荣和但选择不荣和。

#### 示例

```
玩家A立直
玩家B打出：3万（玩家A可以荣和）
玩家A选择不荣和
→ 玩家A进入立直后振听
→ 之后只能自摸，不能荣和
```

#### 判断方法

1. **检查立直状态**：是否已立直
2. **检查可荣和牌**：立直后是否有可以荣和的牌
3. **检查是否荣和**：如果选择不荣和，进入振听

#### 解除方法

- **自摸和牌**：只能通过自摸和牌解除
- **不能改变听牌**：立直后不能改变听牌

## 三、振听的详细规则

### 3.1 舍牌振听的判断

#### 判断时机

- **每次打牌后**：检查是否振听
- **每次听牌变化后**：检查是否振听

#### 判断逻辑

```go
func CheckFuriten(player *Player) bool {
    // 1. 检查听牌
    waits := CheckTenpai(player.Hand)
    if len(waits) == 0 {
        return false // 未听牌，不振听
    }
    
    // 2. 检查舍牌
    for _, wait := range waits {
        if player.HasDiscarded(wait) {
            return true // 听牌中包含舍牌，振听
        }
    }
    
    return false
}
```

#### 特殊情况

- **暗杠后**：暗杠的牌不算舍牌
- **鸣牌后**：鸣牌时打出的牌算舍牌

### 3.2 同巡振听的判断

#### 判断时机

- **每次可以荣和时**：检查是否选择荣和
- **本巡内**：持续到下一巡

#### 判断逻辑

```go
func CheckSameTurnFuriten(player *Player, game *Game) bool {
    // 检查本巡内是否有可以荣和但未荣和的情况
    if player.CanRonThisTurn && !player.RonThisTurn {
        return true
    }
    return false
}
```

#### 解除时机

- **下一巡开始**：自动解除
- **自摸和牌**：自然解除

### 3.3 立直后振听的判断

#### 判断时机

- **立直后每次可以荣和时**：检查是否选择荣和

#### 判断逻辑

```go
func CheckRiichiFuriten(player *Player) bool {
    if !player.IsRiichi {
        return false
    }
    
    // 检查立直后是否有可以荣和但未荣和的情况
    if player.CanRonAfterRiichi && !player.RonAfterRiichi {
        return true
    }
    
    return false
}
```

#### 解除方法

- **只能自摸**：立直后振听只能通过自摸解除
- **不能改变听牌**：立直后不能改变听牌

## 四、振听的组合情况

### 4.1 多种振听同时存在

可以同时存在多种振听：

```
舍牌振听 + 同巡振听
舍牌振听 + 立直后振听
同巡振听 + 立直后振听
```

### 4.2 振听的优先级

- **立直后振听**：最严格，只能自摸解除
- **同巡振听**：下一巡自动解除
- **舍牌振听**：改变听牌或自摸解除

## 五、振听的实际应用

### 5.1 进攻时的注意事项

#### 避免振听

1. **谨慎打牌**：避免打出听牌中的牌
2. **及时荣和**：可以荣和时及时荣和
3. **改变听牌**：如果振听，考虑改变听牌

#### 利用振听

1. **故意振听**：有时故意振听，只追求自摸
2. **防守策略**：振听后更安全（不会放铳）

### 5.2 防守时的读牌

#### 判断对手振听

1. **观察舍牌**：对手是否打过听牌
2. **观察行为**：对手是否选择不荣和
3. **推断听牌**：根据振听推断听牌

#### 利用对手振听

1. **安全打牌**：如果对手振听，可以打相对安全的牌
2. **施加压力**：通过打牌给对手压力

## 六、开发实现

### 6.1 振听状态管理

```go
type FuritenState struct {
    IsFuriten           bool   // 是否振听
    FuritenType         string // 振听类型
    DiscardFuritenWaits []Tile // 舍牌振听的听牌
    SameTurnFuriten     bool   // 同巡振听
    RiichiFuriten       bool   // 立直后振听
}

func (p *Player) UpdateFuritenState() {
    // 1. 检查舍牌振听
    waits := CheckTenpai(p.Hand)
    discardFuriten := false
    for _, wait := range waits {
        if p.HasDiscarded(wait) {
            discardFuriten = true
            break
        }
    }
    
    // 2. 检查同巡振听
    sameTurnFuriten := p.CanRonThisTurn && !p.RonThisTurn
    
    // 3. 检查立直后振听
    riichiFuriten := false
    if p.IsRiichi {
        riichiFuriten = p.CanRonAfterRiichi && !p.RonAfterRiichi
    }
    
    // 4. 综合判断
    p.IsFuriten = discardFuriten || sameTurnFuriten || riichiFuriten
}
```

### 6.2 荣和判定

```go
func CanRon(player *Player, tile Tile) bool {
    // 1. 检查基本和牌条件
    if !CanWin(player.Hand, tile) {
        return false
    }
    
    // 2. 检查振听
    if player.IsFuriten {
        return false // 振听不能荣和
    }
    
    // 3. 检查役
    if !HasYaku(player.Hand, tile, false) {
        return false
    }
    
    return true
}
```

### 6.3 自摸判定

```go
func CanTsumo(player *Player, tile Tile) bool {
    // 1. 检查基本和牌条件
    if !CanWin(player.Hand, tile) {
        return false
    }
    
    // 2. 振听不影响自摸
    // （不需要检查振听）
    
    // 3. 检查役
    if !HasYaku(player.Hand, tile, true) {
        return false
    }
    
    return true
}
```

### 6.4 同巡振听处理

```go
func OnPlayerDiscard(player *Player, tile Tile) {
    // 检查其他玩家是否可以荣和
    for _, otherPlayer := range game.Players {
        if otherPlayer.Index == player.Index {
            continue
        }
        
        if CanRon(otherPlayer, tile) {
            // 标记可以荣和
            otherPlayer.CanRonThisTurn = true
            otherPlayer.RonTile = tile
        }
    }
}

func OnTurnEnd(player *Player) {
    // 检查同巡振听
    if player.CanRonThisTurn && !player.RonThisTurn {
        player.SameTurnFuriten = true
    }
    
    // 下一巡重置
    player.CanRonThisTurn = false
    player.RonTile = Tile{}
}
```

## 七、常见问题

### Q1: 振听时可以自摸吗？

**A**: 可以。振听只影响荣和，不影响自摸。

### Q2: 如何解除振听？

**A**: 
- **舍牌振听**：改变听牌或自摸和牌
- **同巡振听**：下一巡自动解除或自摸和牌
- **立直后振听**：只能自摸和牌

### Q3: 立直后振听可以解除吗？

**A**: 只能通过自摸和牌解除。因为立直后不能改变听牌。

### Q4: 暗杠的牌算舍牌吗？

**A**: 不算。暗杠的牌不算舍牌，不会导致舍牌振听。

### Q5: 同巡振听持续多久？

**A**: 持续到下一巡开始。下一巡自动解除。

## 总结

振听是立直麻将的重要限制规则：

1. **三种类型**：舍牌振听、同巡振听、立直后振听
2. **核心规则**：不能荣和，但可以自摸
3. **解除方法**：根据类型不同，解除方法不同
4. **策略影响**：影响进攻和防守策略

在开发实现时，需要准确判断各种振听状态，正确处理荣和和自摸的判定，确保游戏规则的正确性。

