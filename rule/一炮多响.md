# 麻将游戏逻辑设计：决策处理与放铳冲突

## 一、打牌提示逻辑的架构设计

### 核心原则：**服务端为主，客户端为辅**

### 1. 为什么服务端必须做决策判断

#### 安全性考虑

- 

  **防作弊**：客户端不可信，必须由服务端验证

- 

  **一致性**：确保所有玩家看到相同的可操作选项

- 

  **权威性**：服务端是游戏状态的唯一真实来源

#### 技术实现

```
客户端行为 → 服务端验证 → 广播结果 → 客户端更新
```

### 2. 具体逻辑分工

#### 服务端职责

```
// 1. 鸣牌判定（碰、杠、吃）
func CheckMeldOptions(player Player, discardedTile Tile) []MeldOption {
    // 计算所有可能的鸣牌组合
    // 需要考虑：振听规则、特殊牌型限制等
}

// 2. 和牌判定
func CheckWinOptions(player Player, tile Tile, isTsumo bool) []WinOption {
    // 计算所有可能的和牌方式
    // 包括：役种、番数、符数
}

// 3. 立直判定
func CheckRiichiEligibility(player Player) bool {
    // 条件检查：
    // - 门清状态
    // - 至少1000点
    // - 听牌状态
    // - 非振听
}

// 4. 听牌判定
func CheckTenpai(player Player) []WaitTile {
    // 计算所有听牌可能的牌
    // 包括：听牌型、有效牌、枚数
}

// 5. 振听判定
func CheckFuriten(player Player) bool {
    // 检查是否振听
    // 包括：同巡振听、立直后振听、舍牌振听
}
```

#### 客户端职责

```
// 1. 显示服务端下发的可操作选项
type OperationOptions struct {
    CanPon     bool
    CanChi     []ChiOption
    CanKan     []KanOption
    CanRon     bool
    CanTsumo   bool
    CanRiichi  bool
    CanPass    bool
    Timeout    int  // 操作时限
}

// 2. 收集玩家选择
func OnPlayerChoice(operationType OperationType, details interface{}) {
    // 发送到服务端验证
    SendToServer(operationType, details)
}

// 3. 本地预览（非强制）
func ShowPreview(player Player, tile Tile) {
    // 可操作选项的本地预览
    // 注意：最终以服务端为准
}
```

### 3. 决策流程时序

```
1. 玩家A打出一张牌X
2. 服务端：
   a. 记录牌X到牌河
   b. 计算B、C、D可操作选项
   c. 向B、C、D发送操作选项和超时时间
3. 客户端B/C/D：
   a. 显示操作按钮（碰、杠、吃、和等）
   b. 开始倒计时
4. 客户端选择操作 → 发送到服务端
5. 服务端：
   a. 验证操作合法性
   b. 处理优先级冲突（多人可以和牌时）
   c. 执行第一个有效操作
   d. 广播结果
```

### 4. 优先级处理

#### 操作优先级顺序（从高到低）

1. 

   **和牌**（荣和）

2. 

   **杠**（大明杠）

3. 

   **碰**

4. 

   **吃**

5. 

   **摸牌/打牌**

#### 特殊情况

- 

  **立直宣言**：在摸牌后，打牌前判断

- 

  **暗杠/加杠**：在摸牌后判断

- 

  **九种九牌**：在第一巡摸牌后判断

## 二、放铳多个（一炮多响）的处理方案

### 1. 规则背景

#### 不同规则差异

- 

  **日本立直麻将**：通常**允许**一炮多响

- 

  **中国竞技麻将**：通常**不允许**一炮多响

- 

  **雀魂规则**：允许一炮多响

### 2. 处理逻辑的核心问题

#### 冲突场景

```
玩家A打出牌X
玩家B：可以荣和
玩家C：也可以荣和
玩家D：可以碰牌X
```

#### 需要解决的问题

1. 

   **谁有优先权**？

2. 

   **如何处理多个和牌请求**？

3. 

   **时间窗口如何设计**？

### 3. 推荐方案：**优先级+时间窗口**结合

#### 总体架构

```
type ConflictResolution struct {
    // 操作优先级
    OperationPriority map[OperationType]int
    
    // 时间窗口配置
    TimeWindowConfig struct {
        BaseTimeout    int // 基础超时（如3秒）
        ExtraTime     int // 额外缓冲时间（如1秒）
        MaxWaitTime   int // 最大等待时间
    }
    
    // 冲突解决策略
    Strategy ConflictStrategy
}

type ConflictStrategy int
const (
    StrategyFirstCome Strategy = iota  // 先到先得
    StrategySimultaneous               // 同时处理
    StrategyPriority                   // 优先级优先
)
```

### 4. 具体实现方案

#### 方案一：**时间窗口+轮询检查**（推荐）

```
// 步骤1：检测到可鸣牌/和牌
func OnDiscardTile(playerIndex int, tile Tile) {
    // 1. 收集所有玩家的可操作选项
    optionsByPlayer := make(map[int][]Operation)
    for i := 0; i < 4; i++ {
        if i == playerIndex { continue } // 跳过出牌者
        options := CalculateOptions(players[i], tile)
        if len(options) > 0 {
            optionsByPlayer[i] = options
        }
    }
    
    // 2. 如果有任何玩家可和牌，进入和牌处理流程
    if HasRon(optionsByPlayer) {
        HandleRonConflict(optionsByPlayer)
    } else if HasKan(optionsByPlayer) {
        HandleKanPriority(optionsByPlayer)
    } else {
        // 普通鸣牌处理
        HandleNormalCalls(optionsByPlayer)
    }
}

// 步骤2：处理多个和牌冲突
func HandleRonConflict(optionsByPlayer map[int][]Operation) {
    // 启动时间窗口
    startTime := time.Now()
    timeout := 3 * time.Second
    
    // 存储接收到的和牌请求
    ronRequests := make(map[int]time.Time)
    allPlayersResponded := false
    
    // 等待时间窗口
    for time.Since(startTime) < timeout && !allPlayersResponded {
        // 检查是否有玩家选择和牌
        for playerID, reqTime := range GetPlayerResponses() {
            if IsRonRequest(req) {
                ronRequests[playerID] = time.Now()
            }
        }
        
        // 检查是否所有有选项的玩家都已响应
        allPlayersResponded = CheckAllResponded(optionsByPlayer, ronRequests)
        
        time.Sleep(50 * time.Millisecond) // 避免忙等待
    }
    
    // 时间窗口结束，处理结果
    ProcessRonResults(ronRequests, optionsByPlayer)
}

// 步骤3：处理和牌结果
func ProcessRonResults(ronRequests map[int]time.Time, options map[int][]Operation) {
    // 情况1：没有人和牌 → 进入鸣牌处理
    if len(ronRequests) == 0 {
        HandleNormalCalls(options)
        return
    }
    
    // 情况2：只有一个人和牌 → 直接和牌
    if len(ronRequests) == 1 {
        for playerID := range ronRequests {
            ExecuteRon(playerID)
            return
        }
    }
    
    // 情况3：多人和牌 → 一炮多响
    // 雀魂规则：允许多人和牌
    ExecuteMultipleRon(ronRequests)
}
```

#### 方案二：**优先级队列+时间窗口**

```
type OperationRequest struct {
    PlayerID   int
    Operation  OperationType
    Priority   int           // 和牌=100, 杠=80, 碰=60, 吃=40
    Timestamp  time.Time     // 请求时间
    Details    interface{}   // 操作详情
}

func ProcessSimultaneousRequests(requests []OperationRequest) {
    // 1. 按优先级排序
    sort.Slice(requests, func(i, j int) bool {
        if requests[i].Priority != requests[j].Priority {
            return requests[i].Priority > requests[j].Priority
        }
        // 同优先级按时间排序
        return requests[i].Timestamp.Before(requests[j].Timestamp)
    })
    
    // 2. 处理最高优先级
    highestPriority := requests[0].Priority
    
    // 3. 如果是和牌，检查是否允许多人和牌
    if highestPriority == 100 { // 和牌优先级
        if AllowMultipleRon {
            // 执行所有和牌
            for _, req := range requests {
                if req.Priority == 100 {
                    ExecuteRon(req.PlayerID, req.Details)
                }
            }
        } else {
            // 只执行第一个和牌
            ExecuteRon(requests[0].PlayerID, requests[0].Details)
        }
    } else {
        // 其他操作只执行第一个
        ExecuteOperation(requests[0])
    }
}
```

### 5. 时间窗口算法设计

#### 关键参数

```
type TimeWindowConfig struct {
    // 基本超时
    BaseTimeout       time.Duration  // 3-5秒
    
    // 扩展规则
    ExtendOnMultiple  bool           // 多人和牌时是否延长
    MinResponseTime   time.Duration  // 最小响应时间（如0.5秒）
    MaxResponseTime   time.Duration  // 最大响应时间（如10秒）
    
    // 网络补偿
    NetworkLatency    time.Duration  // 网络延迟补偿
    GracePeriod       time.Duration  // 宽限期
}
```

#### 智能时间窗口算法

```
func CalculateDynamicTimeout(availableOptions []OperationType) time.Duration {
    baseTimeout := 3 * time.Second
    
    // 根据操作复杂度调整
    if ContainsRon(availableOptions) {
        // 和牌需要更多时间计算番数
        baseTimeout += 1 * time.Second
    }
    
    if ContainsChi(availableOptions) {
        // 吃牌有多个选择
        baseTimeout += 0.5 * time.Second
    }
    
    // 根据游戏阶段调整
    if IsLateGame() {
        baseTimeout += 0.5 * time.Second
    }
    
    return baseTimeout
}
```

### 6. 处理边界情况

#### 情况1：网络延迟差异

```
func AdjustForNetworkLatency(requests map[int]time.Time) map[int]time.Time {
    adjusted := make(map[int]time.Time)
    for playerID, reqTime := range requests {
        // 减去该玩家的平均网络延迟
        latency := GetPlayerLatency(playerID)
        adjusted[playerID] = reqTime.Add(-latency)
    }
    return adjusted
}
```

#### 情况2：几乎同时到达

```
func AreSimultaneous(times []time.Time, threshold time.Duration) bool {
    if len(times) < 2 {
        return false
    }
    
    minTime := times[0]
    maxTime := times[0]
    for _, t := range times {
        if t.Before(minTime) { minTime = t }
        if t.After(maxTime) { maxTime = t }
    }
    
    return maxTime.Sub(minTime) <= threshold
}
```

#### 情况3：玩家超时

```
func HandlePlayerTimeout(optionsByPlayer map[int][]Operation) {
    // 检查哪些玩家还未响应
    for playerID, options := range optionsByPlayer {
        if !HasResponded(playerID) {
            // 自动选择"过"（跳过）
            AutoPass(playerID, options)
        }
    }
}
```

### 7. 雀魂的实际实现参考

根据观察，雀魂采用：

#### 和牌处理

1. 

   **允许一炮多响**

2. 

   **时间窗口固定3-5秒**

3. 

   **几乎同时的和牌都有效**

#### 操作优先级

1. 

   和牌（荣和）

2. 

   杠（大明杠、加杠、暗杠）

3. 

   碰

4. 

   吃

5. 

   立直（在摸牌后）

#### 视觉提示

- 

  倒计时显示

- 

  操作按钮高亮

- 

  自动"过"按钮

### 8. 推荐架构

```
// 完整的冲突解决管理器
type ConflictResolver struct {
    config ConflictConfig
    
    // 状态
    activeRequests map[int]OperationRequest
    responseCount  int
    timer          *time.Timer
    
    // 回调
    onTimeout      func()
    onResolution   func(result ConflictResult)
}

func (cr *ConflictResolver) StartResolution(optionsByPlayer map[int][]Operation) {
    // 1. 计算超时时间
    timeout := cr.CalculateTimeout(optionsByPlayer)
    
    // 2. 启动计时器
    cr.timer = time.AfterFunc(timeout, cr.handleTimeout)
    
    // 3. 等待玩家响应
    go cr.waitForResponses(optionsByPlayer)
}

func (cr *ConflictResolver) waitForResponses(optionsByPlayer map[int][]Operation) {
    for {
        select {
        case req := <-cr.requestChannel:
            cr.activeRequests[req.PlayerID] = req
            
            // 检查是否已收集所有必要响应
            if cr.hasAllRequiredResponses(optionsByPlayer) {
                cr.processResults()
                return
            }
            
        case <-cr.timer.C:
            cr.processResults()
            return
        }
    }
}
```

## 三、开发建议

### 1. 阶段化实现

1. 

   **第一阶段**：先实现单人响应（无冲突）

2. 

   **第二阶段**：添加优先级处理

3. 

   **第三阶段**：实现时间窗口

4. 

   **第四阶段**：支持一炮多响

### 2. 测试要点

- 

  网络延迟模拟

- 

  同时请求处理

- 

  超时和自动跳过

- 

  多种冲突场景

### 3. 客户端优化

- 

  操作按钮的明确提示

- 

  倒计时可视化

- 

  网络状态显示

- 

  操作历史记录

### 4. 监控和调试

- 

  记录所有决策时间戳

- 

  记录冲突解决结果

- 

  性能监控（响应时间分布）

## 四、总结

### 问题1：打牌提示逻辑

- 

  **服务端为主**：计算所有合法操作

- 

  **客户端显示**：只显示服务端发送的选项

- 

  **服务端验证**：最终验证所有操作

### 问题2：放铳多个处理

- 

  **推荐方案**：时间窗口 + 优先级

- 

  **雀魂规则**：允许一炮多响

- 

  **实现要点**：

  1. 

     固定时间窗口（3-5秒）

  2. 

     收集所有玩家选择

  3. 

     按优先级处理冲突

  4. 

     支持多人和牌

  5. 

     处理边界情况（超时、网络延迟）

### 关键决策点

1. 

   **是否允许多人和牌**：根据规则定

2. 

   **时间窗口长度**：平衡游戏节奏和玩家体验

3. 

   **优先级顺序**：和牌 > 杠 > 碰 > 吃

4. 

   **超时处理**：自动跳过或默认操作

这样设计既保证了公平性，又提供了良好的玩家体验，同时处理了各种边界情况。