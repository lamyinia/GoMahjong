# 从游戏得点到段位分的转换系统

将游戏内点数转换为段位分（R值/天凤值/雀魂段位分）是竞技麻将的核心。现方案。

## 一、核心设计目标

### 1. 公平性

- 战胜强对手应得更多分

- 输给弱对手应扣更多分

- 考虑对手实力差异

### 2. 稳定性

- 新账号快速定级

- 老账号稳定波动

- 防止刷分

### 3. 体验性

- 连胜有奖励

- 连败有保护

- 体现技术进步

## 二、雀魂/天凤的经典算法

### 1. 天凤R值算法（经典模型）

天凤使用**基于顺位的多人Elo变体**：

#### 计算公式

```
ΔR = K × (实际顺位分 - 预期顺位分)
```

#### 各组件解析

**1. 实际顺位分**

```
1位: +45
2位: +5  
3位: -25
4位: -45
总分: 0（自平衡）
```

**2. 预期顺位分计算**

```
对于玩家i：
预期顺位分 = 4 - Σ(1 / (1 + 10^((Rj - Ri)/400)))  (j=1 to 4, j≠i)
```

简化理解：预期战胜几个对手

**3. K值（波动系数）**

- 标准局：K=20

- 上桌/下桌：K=30

- 安定段位后：K=10-15

### 2. 天凤算法示例

假设4人R值：2000, 1900, 1800, 1700

**计算预期顺位分**：

```
R=2000玩家：
对1900：胜率 = 1/(1+10^((1900-2000)/400)) ≈ 0.64
对1800：胜率 ≈ 0.76  
对1700：胜率 ≈ 0.85
预期顺位分 = 0.64+0.76+0.85 = 2.25 → 预期2.25位
预期得分 = 2.25位对应的素点（通过插值计算）
```

## 三、雀魂的简化实现

### 1. 基本算法（推测）

雀魂可能使用简化版：

```
ΔR = K × (实际顺位系数 - 预期顺位系数)
```

其中：

```
实际顺位系数：
1位: 1.0
2位: 0.5  
3位: 0.0
4位: -0.5
```

### 2. 预期顺位系数计算

```
预期系数 = 1 / (1 + 10^((对手平均R - 自己R)/400))
```

### 3. 雀魂特色调整

1. **段位保护**：
   - 初心/雀士：不掉段
   
   - 雀豪以上：有保护场
   
2. **活动加成**：
   - 活动期间加分多
   
   - 首胜奖励
   
3. **匹配平衡**：
- 段位相近匹配
   
- 隐藏分机制

## 四、多种算法对比

### 方案1：简单顺位加减分

```
// 最简单但不推荐
func SimpleRanking(points map[int]int) map[int]int {
    // 按最终点数排序
    sortedPlayers := sortByPoints(points)
    
    changes := make(map[int]int)
    for i, playerID := range sortedPlayers {
        switch i {
        case 0: changes[playerID] = +20  // 1位
        case 1: changes[playerID] = +10  // 2位  
        case 2: changes[playerID] = -10  // 3位
        case 3: changes[playerID] = -20  // 4位
        }
    }
    return changes
}
```

**缺点**：不考虑对手实力，不公平

### 方案2：基于点数差的Elo变体

```
// 考虑点数差异
func PointBasedElo(ratings map[int]int, points map[int]int) map[int]int {
    changes := make(map[int]int)
    K := 32
    
    for i := 0; i < 4; i++ {
        expectedScore := 0.0
        actualScore := 0.0
        
        for j := 0; j < 4; j++ {
            if i == j { continue }
            
            // 预期胜率
            expectedScore += 1.0 / (1.0 + math.Pow(10, float64(ratings[j]-ratings[i])/400.0))
            
            // 实际胜负（按点数比较）
            if points[i] > points[j] {
                actualScore += 1.0
            } else if points[i] == points[j] {
                actualScore += 0.5
            }
        }
        
        // 转换为顺位系数
        expectedRankCoef := 1.5 - expectedScore/3.0
        actualRankCoef := 1.5 - float64(getRank(i, points))/3.0
        
        changes[i] = int(float64(K) * (actualRankCoef - expectedRankCoef))
    }
    
    return changes
}
```

### 方案3：天凤风格算法（推荐）

```
type RatingSystem struct {
    K           float64 // 波动系数
    InitialR    int     // 初始R值
    FloorR      int     // 保底线
    MaxChange   int     // 单局最大变动
}

func (rs *RatingSystem) CalculateChanges(ratings []float64, points []int) []float64 {
    // 1. 将点数转换为顺位
    ranks := getRanksFromPoints(points)
    
    // 2. 计算实际顺位分
    actualScores := rs.rankToScore(ranks)
    
    // 3. 计算预期顺位分
    expectedScores := rs.calculateExpectedScores(ratings)
    
    // 4. 计算变动
    changes := make([]float64, len(ratings))
    for i := range ratings {
        change := rs.K * (actualScores[i] - expectedScores[i])
        
        // 限制变动范围
        if change > float64(rs.MaxChange) {
            change = float64(rs.MaxChange)
        } else if change < -float64(rs.MaxChange) {
            change = -float64(rs.MaxChange)
        }
        
        changes[i] = change
    }
    
    return changes
}

// 顺位转换为天凤素点
func (rs *RatingSystem) rankToScore(ranks []int) []float64 {
    scores := make([]float64, 4)
    for i, rank := range ranks {
        switch rank {
        case 1: scores[i] = 45.0
        case 2: scores[i] = 5.0
        case 3: scores[i] = -25.0
        case 4: scores[i] = -45.0
        }
    }
    return scores
}

// 计算预期顺位分
func (rs *RatingSystem) calculateExpectedScores(ratings []float64) []float64 {
    expected := make([]float64, 4)
    
    for i := 0; i < 4; i++ {
        total := 0.0
        
        for j := 0; j < 4; j++ {
            if i == j { continue }
            
            // 计算对每个对手的预期得分
            diff := ratings[j] - ratings[i]
            expectedWin := 1.0 / (1.0 + math.Pow(10, diff/400.0))
            
            // 转换为素点
            // 预期得分为：击败对手的概率 * 45 - 被击败的概率 * 45
            // 简化：预期与对手的得分差 = 90 * expectedWin - 45
            total += 90.0*expectedWin - 45.0
        }
        
        // 平均后得到预期顺位分
        expected[i] = total / 3.0
    }
    
    return expected
}
```

## 五、完整实现方案

### 1. 数据结构设计

```
type PlayerRating struct {
    PlayerID    string
    Rating      float64   // 隐藏R值
    DisplayRank int       // 显示段位
    GamesPlayed int       // 总局数
    WinRate     float64   // 胜率
    TopRate     float64   // 一位率
    AvgRank     float64   // 平均顺位
    Streak      int       // 连胜/连败
}

type RatingConfig struct {
    KBase       float64   // 基础K值
    KNewPlayer  float64   // 新手K值
    KStable     float64   // 安定后K值
    MinGames    int       // 安定所需对局数
    MaxChange   float64   // 单局最大变动
    DecayRate   float64   // 衰减率（不活跃时）
    
    // 段位映射
    RankThresholds map[string]float64
}
```

### 2. 完整计算流程

```
type RatingCalculator struct {
    config RatingConfig
    stats  map[string]*PlayerStats
}

func (rc *RatingCalculator) ProcessGame(game *GameResult) RatingChanges {
    changes := make(RatingChanges)
    
    // 1. 获取玩家当前R值
    ratings := rc.getPlayerRatings(game.PlayerIDs)
    
    // 2. 计算预期表现
    expected := rc.calculateExpected(ratings)
    
    // 3. 计算实际表现
    actual := rc.calculateActual(game.FinalPoints)
    
    // 4. 计算R值变动
    for i, playerID := range game.PlayerIDs {
        k := rc.getKValue(playerID)
        change := k * (actual[i] - expected[i])
        
        // 应用限制
        change = rc.applyLimits(playerID, change)
        
        changes[playerID] = change
    }
    
    // 5. 更新连胜/连败
    rc.updateStreaks(game, changes)
    
    return changes
}

// 计算预期表现
func (rc *RatingCalculator) calculateExpected(ratings []float64) []float64 {
    n := len(ratings)
    expected := make([]float64, n)
    
    for i := 0; i < n; i++ {
        sum := 0.0
        for j := 0; j < n; j++ {
            if i == j { continue }
            
            // 对数胜率模型
            diff := ratings[j] - ratings[i]
            winProb := 1.0 / (1.0 + math.Pow(10, diff/400.0))
            
            // 在多人游戏中，预期排名分
            // 这里使用天凤的近似公式
            sum += winProb
        }
        
        // 预期顺位 = 4 - 预期战胜对手数
        // 转换为天凤素点
        expectedWins := sum
        expectedRank := 4 - expectedWins
        expected[i] = rc.rankToScore(expectedRank)
    }
    
    return expected
}

// 从最终点数计算实际表现
func (rc *RatingCalculator) calculateActual(points map[string]int) map[string]float64 {
    // 按点数排序得到顺位
    sorted := rc.sortByPoints(points)
    actual := make(map[string]float64)
    
    rankPoints := []float64{45.0, 5.0, -25.0, -45.0}
    
    for rank, playerID := range sorted {
        actual[playerID] = rankPoints[rank]
    }
    
    return actual
}

// 动态K值
func (rc *RatingCalculator) getKValue(playerID string) float64 {
    stats := rc.stats[playerID]
    
    // 新手期
    if stats.GamesPlayed < 20 {
        return rc.config.KNewPlayer  // 如40
    }
    
    // 安定后
    if stats.GamesPlayed > rc.config.MinGames {
        return rc.config.KStable  // 如15
    }
    
    // 普通期
    return rc.config.KBase  // 如20
}
```

### 3. 段位升降级系统

```
type RankSystem struct {
    Ranks []RankInfo
}

type RankInfo struct {
    Name      string
    MinRating float64
    MaxRating float64
    Promotion float64  // 升级线
    Demotion  float64  // 降级线
    Protection bool    // 段位保护
}

func (rs *RankSystem) UpdateRank(player *PlayerRating) {
    // 检查是否升级
    for _, rank := range rs.Ranks {
        if player.Rating >= rank.Promotion {
            // 升级处理
            player.DisplayRank = rank.Name
            
            // 升级奖励
            player.Rating += 100  // 升级加成
            break
        }
    }
    
    // 检查是否降级
    // ... 类似逻辑
}
```

## 六、雀魂的特色功能

### 1. 段位保护机制

```
// 雀士段位不掉段
func (rc *RatingCalculator) applyProtection(playerID string, change float64) float64 {
    stats := rc.stats[playerID]
    
    // 雀士及以下不掉段
    if stats.DisplayRank <= 2 { // 雀士
        if change < 0 && stats.Rating+change < stats.RankFloor {
            return stats.RankFloor - stats.Rating
        }
    }
    
    // 保护场机制
    if stats.ProtectionGames > 0 {
        if change < 0 {
            stats.ProtectionGames--
            return 0  // 不扣分
        }
    }
    
    return change
}
```

### 2. 连胜/连败补偿

```
func (rc *RatingCalculator) applyStreakBonus(playerID string, change float64) float64 {
    stats := rc.stats[playerID]
    
    // 连胜奖励
    if stats.Streak > 0 {
        bonus := 1.0 + float64(stats.Streak)*0.1
        if bonus > 2.0 { bonus = 2.0 }
        change *= bonus
    }
    
    // 连败保护
    if stats.Streak < 0 {
        protection := 1.0 - float64(-stats.Streak)*0.05
        if protection < 0.5 { protection = 0.5 }
        change *= protection
    }
    
    return change
}
```

### 3. 匹配平衡加成

```
// 对手平均R值高于自己时，获得加成
func (rc *RatingCalculator) calculateOpponentBonus(playerRating float64, opponentRatings []float64) float64 {
    avgOpponent := average(opponentRatings)
    diff := avgOpponent - playerRating
    
    if diff > 0 {
        // 对手更强，获得加成系数
        return 1.0 + diff/400.0
    }
    return 1.0
}
```

## 七、测试和验证

### 1. 测试用例

```
func TestRatingSystem(t *testing.T) {
    tests := []struct{
        name    string
        ratings []float64
        points  []int
        expect  []float64
    }{
        {
            name: "平均实力，正常顺位",
            ratings: []float64{1500, 1500, 1500, 1500},
            points: []int{35000, 25000, 20000, 20000},
            expect: []float64{+20, +5, -10, -15}, // 大致范围
        },
        {
            name: "以弱胜强",
            ratings: []float64{1400, 1500, 1600, 1700},
            points: []int{40000, 30000, 20000, 10000}, // 弱者逆袭
            expect: []float64{+30, +10, -15, -25}, // 弱者加分多
        },
    }
}
```

### 2. 统计分析

- 平均变动应在±20左右

- 长期应收敛到真实水平

- 胜率应与R值正相关

## 八、推荐实施方案

### 阶段1：简单实现

```
// 最简单可用的版本
func SimpleRatingChange(ratings map[string]float64, points map[string]int) map[string]float64 {
    // 1. 按点数排序
    sorted := sortPlayersByPoints(points)
    
    changes := make(map[string]float64)
    K := 20.0
    
    // 2. 计算预期顺位
    for i, playerID := range sorted {
        // 简化预期：假设实力平均时预期2.5位
        expectedRank := 2.5
        
        // 根据R值调整预期
        rating := ratings[playerID]
        avgOpponent := averageOpponentRating(ratings, playerID)
        if rating > avgOpponent {
            expectedRank -= 0.3
        } else {
            expectedRank += 0.3
        }
        
        // 3. 计算变动
        actualRank := float64(i + 1)
        change := K * (expectedRank - actualRank)
        
        changes[playerID] = change
    }
    
    return changes
}
```

### 阶段2：完整天凤算法

```
// 实现完整的天凤R值算法
func TenhouRating(ratings []float64, points []int) []float64 {
    n := len(ratings)
    changes := make([]float64, n)
    
    // 计算实际顺位分
    actualScores := calculateActualScores(points)
    
    for i := 0; i < n; i++ {
        // 计算预期战胜每个对手的概率
        expectedScore := 0.0
        for j := 0; j < n; j++ {
            if i == j { continue }
            diff := ratings[j] - ratings[i]
            expectedScore += 1.0 / (1.0 + math.Pow(10, diff/400.0))
        }
        
        // 转换为预期顺位分
        expectedTenhouScore := 45.0 * (expectedScore - 1.5)
        
        // 计算变动
        K := getKValue(ratings[i])
        changes[i] = K * (actualScores[i] - expectedTenhouScore) / 45.0
    }
    
    return changes
}
```

## 九、监控和维护

### 1. 关键指标

- 平均R值变动

- 段位分布

- 匹配公平性

- 爬升速度

### 2. 调整策略

```
// 动态调整K值
func (rc *RatingCalculator) adjustKValue() {
    // 监测平均变动
    avgChange := rc.getAverageChange()
    
    if avgChange > 25 {
        rc.config.KBase *= 0.9  // 变动太大，降低K
    } else if avgChange < 15 {
        rc.config.KBase *= 1.1  // 变动太小，提高K
    }
}
```

## 十、总结

### 核心要点

1. **从点数到顺位**：首先将最终点数转换为顺位

2. **从顺位到R值变动**：通过对比实际顺位和预期顺位计算变动

3. **预期顺位的计算**：基于玩家R值差异，使用Elo公式变体

4. **K值调整**：新手期K值大，安定后K值小

### 推荐算法

对于您的麻将服务器，建议：

1. **初始版本**：使用简单顺位加减分，按对手实力加权

2. **稳定版本**：实现完整的天凤风格算法

3. **高级功能**：添加段位保护、连胜奖励、匹配加成

### 最终建议公式

```
ΔR = K × (实际顺位分 - 预期顺位分)

其中：
- 实际顺位分：1位=45, 2位=5, 3位=-25, 4位=-45
- 预期顺位分 = Σ[1 / (1 + 10^((Rj - Ri)/400))] × 90 - 45
- K值：新手40，普通20，安定15
```

这个系统能确保：

- 战胜强敌获得更多分

- 意外翻车扣除合理分

- 长期反应真实实力

- 提供良好的竞技体验